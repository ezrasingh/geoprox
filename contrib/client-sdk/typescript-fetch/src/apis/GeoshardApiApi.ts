/* tslint:disable */
/* eslint-disable */
/**
 * geoprox-server
 * Geoprox server implementation providing a HTTP API for geospatial queries and position tracking
 *
 * The version of the OpenAPI document: 0.4.2
 * Contact: singhezra@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateIndexResponse,
  DropIndexResponse,
  InsertKey,
  InsertKeyBatch,
  InsertKeyBatchResponse,
  InsertKeyResponse,
  QueryRangeManyResponse,
  QueryRangeResponse,
  RemoveKey,
  RemoveKeyBatch,
  RemoveKeyBatchResponse,
  RemoveKeyResponse,
} from '../models/index';
import {
    CreateIndexResponseFromJSON,
    CreateIndexResponseToJSON,
    DropIndexResponseFromJSON,
    DropIndexResponseToJSON,
    InsertKeyFromJSON,
    InsertKeyToJSON,
    InsertKeyBatchFromJSON,
    InsertKeyBatchToJSON,
    InsertKeyBatchResponseFromJSON,
    InsertKeyBatchResponseToJSON,
    InsertKeyResponseFromJSON,
    InsertKeyResponseToJSON,
    QueryRangeManyResponseFromJSON,
    QueryRangeManyResponseToJSON,
    QueryRangeResponseFromJSON,
    QueryRangeResponseToJSON,
    RemoveKeyFromJSON,
    RemoveKeyToJSON,
    RemoveKeyBatchFromJSON,
    RemoveKeyBatchToJSON,
    RemoveKeyBatchResponseFromJSON,
    RemoveKeyBatchResponseToJSON,
    RemoveKeyResponseFromJSON,
    RemoveKeyResponseToJSON,
} from '../models/index';

export interface CreateIndexRequest {
    index: string;
}

export interface DropIndexRequest {
    index: string;
}

export interface InsertKeyRequest {
    index: string;
    insertKey: InsertKey;
}

export interface InsertKeyBatchRequest {
    index: string;
    insertKeyBatch: InsertKeyBatch;
}

export interface QueryRangeRequest {
    index: string;
    lat: number;
    lng: number;
    range: number;
    count?: number | null;
    sorted?: boolean | null;
}

export interface QueryRangeManyRequest {
    indices: Array<string>;
    lat: number;
    lng: number;
    range: number;
    count?: number | null;
    sorted?: boolean | null;
}

export interface RemoveKeyRequest {
    index: string;
    removeKey: RemoveKey;
}

export interface RemoveKeyBatchRequest {
    index: string;
    removeKeyBatch: RemoveKeyBatch;
}

/**
 * 
 */
export class GeoshardApiApi extends runtime.BaseAPI {

    /**
     * Creates an in-memory index within this geoshard
     * Create geospatial index
     */
    async createIndexRaw(requestParameters: CreateIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateIndexResponse>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling createIndex().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/shard/{index}`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateIndexResponseFromJSON(jsonValue));
    }

    /**
     * Creates an in-memory index within this geoshard
     * Create geospatial index
     */
    async createIndex(requestParameters: CreateIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateIndexResponse> {
        const response = await this.createIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Drop index. All keys will be lost
     * Deletes geospatial index
     */
    async dropIndexRaw(requestParameters: DropIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DropIndexResponse>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling dropIndex().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/shard/{index}`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DropIndexResponseFromJSON(jsonValue));
    }

    /**
     * Drop index. All keys will be lost
     * Deletes geospatial index
     */
    async dropIndex(requestParameters: DropIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DropIndexResponse> {
        const response = await this.dropIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts key into geospatial index
     * Insert key into index
     */
    async insertKeyRaw(requestParameters: InsertKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InsertKeyResponse>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling insertKey().'
            );
        }

        if (requestParameters['insertKey'] == null) {
            throw new runtime.RequiredError(
                'insertKey',
                'Required parameter "insertKey" was null or undefined when calling insertKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/shard/{index}`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InsertKeyToJSON(requestParameters['insertKey']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InsertKeyResponseFromJSON(jsonValue));
    }

    /**
     * Inserts key into geospatial index
     * Insert key into index
     */
    async insertKey(requestParameters: InsertKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InsertKeyResponse> {
        const response = await this.insertKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts multiple keys into geospatial index
     * Insert multiple keys into index
     */
    async insertKeyBatchRaw(requestParameters: InsertKeyBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InsertKeyBatchResponse>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling insertKeyBatch().'
            );
        }

        if (requestParameters['insertKeyBatch'] == null) {
            throw new runtime.RequiredError(
                'insertKeyBatch',
                'Required parameter "insertKeyBatch" was null or undefined when calling insertKeyBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/shard/{index}/batch`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InsertKeyBatchToJSON(requestParameters['insertKeyBatch']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InsertKeyBatchResponseFromJSON(jsonValue));
    }

    /**
     * Inserts multiple keys into geospatial index
     * Insert multiple keys into index
     */
    async insertKeyBatch(requestParameters: InsertKeyBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InsertKeyBatchResponse> {
        const response = await this.insertKeyBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search geospatial index for all keys within some distance
     * Search index for objects nearby
     */
    async queryRangeRaw(requestParameters: QueryRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryRangeResponse>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling queryRange().'
            );
        }

        if (requestParameters['lat'] == null) {
            throw new runtime.RequiredError(
                'lat',
                'Required parameter "lat" was null or undefined when calling queryRange().'
            );
        }

        if (requestParameters['lng'] == null) {
            throw new runtime.RequiredError(
                'lng',
                'Required parameter "lng" was null or undefined when calling queryRange().'
            );
        }

        if (requestParameters['range'] == null) {
            throw new runtime.RequiredError(
                'range',
                'Required parameter "range" was null or undefined when calling queryRange().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['lat'] != null) {
            queryParameters['lat'] = requestParameters['lat'];
        }

        if (requestParameters['lng'] != null) {
            queryParameters['lng'] = requestParameters['lng'];
        }

        if (requestParameters['range'] != null) {
            queryParameters['range'] = requestParameters['range'];
        }

        if (requestParameters['count'] != null) {
            queryParameters['count'] = requestParameters['count'];
        }

        if (requestParameters['sorted'] != null) {
            queryParameters['sorted'] = requestParameters['sorted'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/shard/{index}`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueryRangeResponseFromJSON(jsonValue));
    }

    /**
     * Search geospatial index for all keys within some distance
     * Search index for objects nearby
     */
    async queryRange(requestParameters: QueryRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryRangeResponse> {
        const response = await this.queryRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search geospatial many indices for all keys within some distance
     * Search multiple indices for objects nearby
     */
    async queryRangeManyRaw(requestParameters: QueryRangeManyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryRangeManyResponse>> {
        if (requestParameters['indices'] == null) {
            throw new runtime.RequiredError(
                'indices',
                'Required parameter "indices" was null or undefined when calling queryRangeMany().'
            );
        }

        if (requestParameters['lat'] == null) {
            throw new runtime.RequiredError(
                'lat',
                'Required parameter "lat" was null or undefined when calling queryRangeMany().'
            );
        }

        if (requestParameters['lng'] == null) {
            throw new runtime.RequiredError(
                'lng',
                'Required parameter "lng" was null or undefined when calling queryRangeMany().'
            );
        }

        if (requestParameters['range'] == null) {
            throw new runtime.RequiredError(
                'range',
                'Required parameter "range" was null or undefined when calling queryRangeMany().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['indices'] != null) {
            queryParameters['indices'] = requestParameters['indices'];
        }

        if (requestParameters['lat'] != null) {
            queryParameters['lat'] = requestParameters['lat'];
        }

        if (requestParameters['lng'] != null) {
            queryParameters['lng'] = requestParameters['lng'];
        }

        if (requestParameters['range'] != null) {
            queryParameters['range'] = requestParameters['range'];
        }

        if (requestParameters['count'] != null) {
            queryParameters['count'] = requestParameters['count'];
        }

        if (requestParameters['sorted'] != null) {
            queryParameters['sorted'] = requestParameters['sorted'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/shard`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueryRangeManyResponseFromJSON(jsonValue));
    }

    /**
     * Search geospatial many indices for all keys within some distance
     * Search multiple indices for objects nearby
     */
    async queryRangeMany(requestParameters: QueryRangeManyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryRangeManyResponse> {
        const response = await this.queryRangeManyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes key from geospatial index
     * Remove key from index
     */
    async removeKeyRaw(requestParameters: RemoveKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RemoveKeyResponse>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling removeKey().'
            );
        }

        if (requestParameters['removeKey'] == null) {
            throw new runtime.RequiredError(
                'removeKey',
                'Required parameter "removeKey" was null or undefined when calling removeKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/shard/{index}`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RemoveKeyToJSON(requestParameters['removeKey']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RemoveKeyResponseFromJSON(jsonValue));
    }

    /**
     * Removes key from geospatial index
     * Remove key from index
     */
    async removeKey(requestParameters: RemoveKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RemoveKeyResponse> {
        const response = await this.removeKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes multiple keys from geospatial index
     * Remove multiple keys from index
     */
    async removeKeyBatchRaw(requestParameters: RemoveKeyBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RemoveKeyBatchResponse>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling removeKeyBatch().'
            );
        }

        if (requestParameters['removeKeyBatch'] == null) {
            throw new runtime.RequiredError(
                'removeKeyBatch',
                'Required parameter "removeKeyBatch" was null or undefined when calling removeKeyBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/shard/{index}/batch`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RemoveKeyBatchToJSON(requestParameters['removeKeyBatch']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RemoveKeyBatchResponseFromJSON(jsonValue));
    }

    /**
     * Removes multiple keys from geospatial index
     * Remove multiple keys from index
     */
    async removeKeyBatch(requestParameters: RemoveKeyBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RemoveKeyBatchResponse> {
        const response = await this.removeKeyBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
