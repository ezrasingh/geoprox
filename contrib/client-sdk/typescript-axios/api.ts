/* tslint:disable */
/* eslint-disable */
/**
 * geoprox-server
 * Geoprox server implementation providing a HTTP API for geospatial queries and position tracking
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: singhezra@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Returns index creation status
 * @export
 * @interface CreateIndexResponse
 */
export interface CreateIndexResponse {
    /**
     * If true index was created
     * @type {boolean}
     * @memberof CreateIndexResponse
     */
    'created': boolean;
    /**
     * If true index alredy exist
     * @type {boolean}
     * @memberof CreateIndexResponse
     */
    'existed': boolean;
}
/**
 * Returns geohash decoded as latitude/longitude with precision errors
 * @export
 * @interface DecodeGeohashResponse
 */
export interface DecodeGeohashResponse {
    /**
     * Latitude
     * @type {number}
     * @memberof DecodeGeohashResponse
     */
    'lat': number;
    /**
     * Latitude error
     * @type {number}
     * @memberof DecodeGeohashResponse
     */
    'lat_error': number;
    /**
     * Longitude
     * @type {number}
     * @memberof DecodeGeohashResponse
     */
    'lng': number;
    /**
     * Longitude error
     * @type {number}
     * @memberof DecodeGeohashResponse
     */
    'lng_error': number;
}
/**
 * Returns index deletion status
 * @export
 * @interface DropIndexResponse
 */
export interface DropIndexResponse {
    /**
     * If true index was deleted
     * @type {boolean}
     * @memberof DropIndexResponse
     */
    'deleted': boolean;
}
/**
 * Arguments for encoding latitude/longitude as geohash
 * @export
 * @interface EncodeLatLng
 */
export interface EncodeLatLng {
    /**
     * Determines geohash length
     * @type {number}
     * @memberof EncodeLatLng
     */
    'depth': number;
    /**
     * Latitude
     * @type {number}
     * @memberof EncodeLatLng
     */
    'lat': number;
    /**
     * Longitude
     * @type {number}
     * @memberof EncodeLatLng
     */
    'lng': number;
}
/**
 * Returns geohash encoded latitude/longitude
 * @export
 * @interface EncodeLatLngResponse
 */
export interface EncodeLatLngResponse {
    /**
     * 
     * @type {string}
     * @memberof EncodeLatLngResponse
     */
    'geohash': string;
}
/**
 * Neighboring geohash regions
 * @export
 * @interface GeohashNeighborsResponse
 */
export interface GeohashNeighborsResponse {
    /**
     * East
     * @type {string}
     * @memberof GeohashNeighborsResponse
     */
    'e': string;
    /**
     * North
     * @type {string}
     * @memberof GeohashNeighborsResponse
     */
    'n': string;
    /**
     * North East
     * @type {string}
     * @memberof GeohashNeighborsResponse
     */
    'ne': string;
    /**
     * North West
     * @type {string}
     * @memberof GeohashNeighborsResponse
     */
    'nw': string;
    /**
     * South
     * @type {string}
     * @memberof GeohashNeighborsResponse
     */
    's': string;
    /**
     * South East
     * @type {string}
     * @memberof GeohashNeighborsResponse
     */
    'se': string;
    /**
     * South West
     * @type {string}
     * @memberof GeohashNeighborsResponse
     */
    'sw': string;
    /**
     * West
     * @type {string}
     * @memberof GeohashNeighborsResponse
     */
    'w': string;
}
/**
 * Arguments for inserting a key
 * @export
 * @interface InsertKey
 */
export interface InsertKey {
    /**
     * Resource key
     * @type {string}
     * @memberof InsertKey
     */
    'key': string;
    /**
     * Latitude
     * @type {number}
     * @memberof InsertKey
     */
    'lat': number;
    /**
     * Longitude
     * @type {number}
     * @memberof InsertKey
     */
    'lng': number;
}
/**
 * Returns key and geohash
 * @export
 * @interface InsertKeyResponse
 */
export interface InsertKeyResponse {
    /**
     * Geohash encoded latitude/longitude
     * @type {string}
     * @memberof InsertKeyResponse
     */
    'geohash': string;
    /**
     * Resource key
     * @type {string}
     * @memberof InsertKeyResponse
     */
    'key': string;
}
/**
 * Nearby resource key
 * @export
 * @interface Neighbor
 */
export interface Neighbor {
    /**
     * Distance in kilometers
     * @type {number}
     * @memberof Neighbor
     */
    'distance': number;
    /**
     * Resource key
     * @type {string}
     * @memberof Neighbor
     */
    'key': string;
}
/**
 * Arguments for range query
 * @export
 * @interface QueryRange
 */
export interface QueryRange {
    /**
     * Maximum number of neighbors that can be returned (default 100)
     * @type {number}
     * @memberof QueryRange
     */
    'count'?: number | null;
    /**
     * Latitude
     * @type {number}
     * @memberof QueryRange
     */
    'lat': number;
    /**
     * Longitude
     * @type {number}
     * @memberof QueryRange
     */
    'lng': number;
    /**
     * Search radius in kilometers
     * @type {number}
     * @memberof QueryRange
     */
    'range': number;
    /**
     * If enabled neighbors will be sorted by distance, nearest to furthest (default false)
     * @type {boolean}
     * @memberof QueryRange
     */
    'sorted'?: boolean | null;
}
/**
 * Returns resource keys found with their distance
 * @export
 * @interface QueryRangeResponse
 */
export interface QueryRangeResponse {
    /**
     * Resource keys found within range
     * @type {Array<Neighbor>}
     * @memberof QueryRangeResponse
     */
    'found': Array<Neighbor>;
}
/**
 * Arguments for removing a key
 * @export
 * @interface RemoveKey
 */
export interface RemoveKey {
    /**
     * Resource key
     * @type {string}
     * @memberof RemoveKey
     */
    'key': string;
}
/**
 * Returns key and deletion status
 * @export
 * @interface RemoveKeyResponse
 */
export interface RemoveKeyResponse {
    /**
     * If true key was removed
     * @type {boolean}
     * @memberof RemoveKeyResponse
     */
    'deleted': boolean;
    /**
     * Resource key
     * @type {string}
     * @memberof RemoveKeyResponse
     */
    'key': string;
}

/**
 * GeohashApiApi - axios parameter creator
 * @export
 */
export const GeohashApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Decode geohash by path param, returns coordinates with precision estimates.
         * @summary Decode geohash into coordinates.
         * @param {string} ghash Geohash encoded region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decodeGeohash: async (ghash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ghash' is not null or undefined
            assertParamExists('decodeGeohash', 'ghash', ghash)
            const localVarPath = `/api/v1/geohash/{ghash}`
                .replace(`{${"ghash"}}`, encodeURIComponent(String(ghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Encode coordinates by query params, returns geohash.
         * @summary Encode coordinates into geohash
         * @param {number} lat Latitude
         * @param {number} lng Longitude
         * @param {number} depth Determines geohash length
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encodeLatlng: async (lat: number, lng: number, depth: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('encodeLatlng', 'lat', lat)
            // verify required parameter 'lng' is not null or undefined
            assertParamExists('encodeLatlng', 'lng', lng)
            // verify required parameter 'depth' is not null or undefined
            assertParamExists('encodeLatlng', 'depth', depth)
            const localVarPath = `/api/v1/geohash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns geohash neighbors in all cardinal directions.
         * @summary Neighboring regions
         * @param {string} ghash Geohash encoded region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNeighbors: async (ghash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ghash' is not null or undefined
            assertParamExists('getNeighbors', 'ghash', ghash)
            const localVarPath = `/api/v1/geohash/{ghash}/neighbors`
                .replace(`{${"ghash"}}`, encodeURIComponent(String(ghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeohashApiApi - functional programming interface
 * @export
 */
export const GeohashApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeohashApiApiAxiosParamCreator(configuration)
    return {
        /**
         * Decode geohash by path param, returns coordinates with precision estimates.
         * @summary Decode geohash into coordinates.
         * @param {string} ghash Geohash encoded region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decodeGeohash(ghash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DecodeGeohashResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decodeGeohash(ghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeohashApiApi.decodeGeohash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Encode coordinates by query params, returns geohash.
         * @summary Encode coordinates into geohash
         * @param {number} lat Latitude
         * @param {number} lng Longitude
         * @param {number} depth Determines geohash length
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async encodeLatlng(lat: number, lng: number, depth: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncodeLatLngResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.encodeLatlng(lat, lng, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeohashApiApi.encodeLatlng']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns geohash neighbors in all cardinal directions.
         * @summary Neighboring regions
         * @param {string} ghash Geohash encoded region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNeighbors(ghash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeohashNeighborsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNeighbors(ghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeohashApiApi.getNeighbors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeohashApiApi - factory interface
 * @export
 */
export const GeohashApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeohashApiApiFp(configuration)
    return {
        /**
         * Decode geohash by path param, returns coordinates with precision estimates.
         * @summary Decode geohash into coordinates.
         * @param {string} ghash Geohash encoded region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decodeGeohash(ghash: string, options?: any): AxiosPromise<DecodeGeohashResponse> {
            return localVarFp.decodeGeohash(ghash, options).then((request) => request(axios, basePath));
        },
        /**
         * Encode coordinates by query params, returns geohash.
         * @summary Encode coordinates into geohash
         * @param {number} lat Latitude
         * @param {number} lng Longitude
         * @param {number} depth Determines geohash length
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encodeLatlng(lat: number, lng: number, depth: number, options?: any): AxiosPromise<EncodeLatLngResponse> {
            return localVarFp.encodeLatlng(lat, lng, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns geohash neighbors in all cardinal directions.
         * @summary Neighboring regions
         * @param {string} ghash Geohash encoded region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNeighbors(ghash: string, options?: any): AxiosPromise<GeohashNeighborsResponse> {
            return localVarFp.getNeighbors(ghash, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeohashApiApi - object-oriented interface
 * @export
 * @class GeohashApiApi
 * @extends {BaseAPI}
 */
export class GeohashApiApi extends BaseAPI {
    /**
     * Decode geohash by path param, returns coordinates with precision estimates.
     * @summary Decode geohash into coordinates.
     * @param {string} ghash Geohash encoded region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeohashApiApi
     */
    public decodeGeohash(ghash: string, options?: RawAxiosRequestConfig) {
        return GeohashApiApiFp(this.configuration).decodeGeohash(ghash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Encode coordinates by query params, returns geohash.
     * @summary Encode coordinates into geohash
     * @param {number} lat Latitude
     * @param {number} lng Longitude
     * @param {number} depth Determines geohash length
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeohashApiApi
     */
    public encodeLatlng(lat: number, lng: number, depth: number, options?: RawAxiosRequestConfig) {
        return GeohashApiApiFp(this.configuration).encodeLatlng(lat, lng, depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns geohash neighbors in all cardinal directions.
     * @summary Neighboring regions
     * @param {string} ghash Geohash encoded region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeohashApiApi
     */
    public getNeighbors(ghash: string, options?: RawAxiosRequestConfig) {
        return GeohashApiApiFp(this.configuration).getNeighbors(ghash, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GeoshardApiApi - axios parameter creator
 * @export
 */
export const GeoshardApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an in-memory index within this geoshard
         * @summary Create geospatial index
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex: async (index: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('createIndex', 'index', index)
            const localVarPath = `/api/v1/shard/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes geospatial index, all keys will be lost
         * @summary Drop index
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropIndex: async (index: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('dropIndex', 'index', index)
            const localVarPath = `/api/v1/shard/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts key into geospatial index
         * @summary Insert key into index
         * @param {string} index 
         * @param {InsertKey} insertKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertKey: async (index: string, insertKey: InsertKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('insertKey', 'index', index)
            // verify required parameter 'insertKey' is not null or undefined
            assertParamExists('insertKey', 'insertKey', insertKey)
            const localVarPath = `/api/v1/shard/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insertKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search geospatial index for all keys within some distance
         * @summary Search nearby
         * @param {number} lat Latitude
         * @param {number} lng Longitude
         * @param {number} range Search radius in kilometers
         * @param {string} index 
         * @param {number | null} [count] Maximum number of neighbors that can be returned (default 100)
         * @param {boolean | null} [sorted] If enabled neighbors will be sorted by distance, nearest to furthest (default false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRange: async (lat: number, lng: number, range: number, index: string, count?: number | null, sorted?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('queryRange', 'lat', lat)
            // verify required parameter 'lng' is not null or undefined
            assertParamExists('queryRange', 'lng', lng)
            // verify required parameter 'range' is not null or undefined
            assertParamExists('queryRange', 'range', range)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('queryRange', 'index', index)
            const localVarPath = `/api/v1/shard/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorted !== undefined) {
                localVarQueryParameter['sorted'] = sorted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removed key from geospatial index
         * @summary Remove key from index
         * @param {string} index 
         * @param {RemoveKey} removeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeKey: async (index: string, removeKey: RemoveKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('removeKey', 'index', index)
            // verify required parameter 'removeKey' is not null or undefined
            assertParamExists('removeKey', 'removeKey', removeKey)
            const localVarPath = `/api/v1/shard/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeoshardApiApi - functional programming interface
 * @export
 */
export const GeoshardApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeoshardApiApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an in-memory index within this geoshard
         * @summary Create geospatial index
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIndex(index: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIndex(index, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoshardApiApi.createIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes geospatial index, all keys will be lost
         * @summary Drop index
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropIndex(index: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropIndex(index, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoshardApiApi.dropIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts key into geospatial index
         * @summary Insert key into index
         * @param {string} index 
         * @param {InsertKey} insertKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertKey(index: string, insertKey: InsertKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsertKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertKey(index, insertKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoshardApiApi.insertKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search geospatial index for all keys within some distance
         * @summary Search nearby
         * @param {number} lat Latitude
         * @param {number} lng Longitude
         * @param {number} range Search radius in kilometers
         * @param {string} index 
         * @param {number | null} [count] Maximum number of neighbors that can be returned (default 100)
         * @param {boolean | null} [sorted] If enabled neighbors will be sorted by distance, nearest to furthest (default false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryRange(lat: number, lng: number, range: number, index: string, count?: number | null, sorted?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryRangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryRange(lat, lng, range, index, count, sorted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoshardApiApi.queryRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removed key from geospatial index
         * @summary Remove key from index
         * @param {string} index 
         * @param {RemoveKey} removeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeKey(index: string, removeKey: RemoveKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsertKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeKey(index, removeKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoshardApiApi.removeKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeoshardApiApi - factory interface
 * @export
 */
export const GeoshardApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeoshardApiApiFp(configuration)
    return {
        /**
         * Creates an in-memory index within this geoshard
         * @summary Create geospatial index
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex(index: string, options?: any): AxiosPromise<CreateIndexResponse> {
            return localVarFp.createIndex(index, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes geospatial index, all keys will be lost
         * @summary Drop index
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropIndex(index: string, options?: any): AxiosPromise<DropIndexResponse> {
            return localVarFp.dropIndex(index, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts key into geospatial index
         * @summary Insert key into index
         * @param {string} index 
         * @param {InsertKey} insertKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertKey(index: string, insertKey: InsertKey, options?: any): AxiosPromise<InsertKeyResponse> {
            return localVarFp.insertKey(index, insertKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Search geospatial index for all keys within some distance
         * @summary Search nearby
         * @param {number} lat Latitude
         * @param {number} lng Longitude
         * @param {number} range Search radius in kilometers
         * @param {string} index 
         * @param {number | null} [count] Maximum number of neighbors that can be returned (default 100)
         * @param {boolean | null} [sorted] If enabled neighbors will be sorted by distance, nearest to furthest (default false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRange(lat: number, lng: number, range: number, index: string, count?: number | null, sorted?: boolean | null, options?: any): AxiosPromise<QueryRangeResponse> {
            return localVarFp.queryRange(lat, lng, range, index, count, sorted, options).then((request) => request(axios, basePath));
        },
        /**
         * Removed key from geospatial index
         * @summary Remove key from index
         * @param {string} index 
         * @param {RemoveKey} removeKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeKey(index: string, removeKey: RemoveKey, options?: any): AxiosPromise<InsertKeyResponse> {
            return localVarFp.removeKey(index, removeKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeoshardApiApi - object-oriented interface
 * @export
 * @class GeoshardApiApi
 * @extends {BaseAPI}
 */
export class GeoshardApiApi extends BaseAPI {
    /**
     * Creates an in-memory index within this geoshard
     * @summary Create geospatial index
     * @param {string} index 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoshardApiApi
     */
    public createIndex(index: string, options?: RawAxiosRequestConfig) {
        return GeoshardApiApiFp(this.configuration).createIndex(index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes geospatial index, all keys will be lost
     * @summary Drop index
     * @param {string} index 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoshardApiApi
     */
    public dropIndex(index: string, options?: RawAxiosRequestConfig) {
        return GeoshardApiApiFp(this.configuration).dropIndex(index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts key into geospatial index
     * @summary Insert key into index
     * @param {string} index 
     * @param {InsertKey} insertKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoshardApiApi
     */
    public insertKey(index: string, insertKey: InsertKey, options?: RawAxiosRequestConfig) {
        return GeoshardApiApiFp(this.configuration).insertKey(index, insertKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search geospatial index for all keys within some distance
     * @summary Search nearby
     * @param {number} lat Latitude
     * @param {number} lng Longitude
     * @param {number} range Search radius in kilometers
     * @param {string} index 
     * @param {number | null} [count] Maximum number of neighbors that can be returned (default 100)
     * @param {boolean | null} [sorted] If enabled neighbors will be sorted by distance, nearest to furthest (default false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoshardApiApi
     */
    public queryRange(lat: number, lng: number, range: number, index: string, count?: number | null, sorted?: boolean | null, options?: RawAxiosRequestConfig) {
        return GeoshardApiApiFp(this.configuration).queryRange(lat, lng, range, index, count, sorted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removed key from geospatial index
     * @summary Remove key from index
     * @param {string} index 
     * @param {RemoveKey} removeKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoshardApiApi
     */
    public removeKey(index: string, removeKey: RemoveKey, options?: RawAxiosRequestConfig) {
        return GeoshardApiApiFp(this.configuration).removeKey(index, removeKey, options).then((request) => request(this.axios, this.basePath));
    }
}



