/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.geoprox.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.geoprox.client.models.CreateIndexResponse
import org.geoprox.client.models.DropIndexResponse
import org.geoprox.client.models.InsertKey
import org.geoprox.client.models.InsertKeyBatch
import org.geoprox.client.models.InsertKeyBatchResponse
import org.geoprox.client.models.InsertKeyResponse
import org.geoprox.client.models.QueryRangeManyResponse
import org.geoprox.client.models.QueryRangeResponse
import org.geoprox.client.models.RemoveKey
import org.geoprox.client.models.RemoveKeyBatch
import org.geoprox.client.models.RemoveKeyBatchResponse
import org.geoprox.client.models.RemoveKeyResponse

import com.squareup.moshi.Json

import org.geoprox.client.infrastructure.ApiClient
import org.geoprox.client.infrastructure.ApiResponse
import org.geoprox.client.infrastructure.ClientException
import org.geoprox.client.infrastructure.ClientError
import org.geoprox.client.infrastructure.ServerException
import org.geoprox.client.infrastructure.ServerError
import org.geoprox.client.infrastructure.MultiValueMap
import org.geoprox.client.infrastructure.PartConfig
import org.geoprox.client.infrastructure.RequestConfig
import org.geoprox.client.infrastructure.RequestMethod
import org.geoprox.client.infrastructure.ResponseType
import org.geoprox.client.infrastructure.Success
import org.geoprox.client.infrastructure.toMultiValue

class GeoshardApiApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Create geospatial index
     * Creates an in-memory index within this geoshard
     * @param index Geospatial index name
     * @return CreateIndexResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createIndex(index: kotlin.String) : CreateIndexResponse {
        val localVarResponse = createIndexWithHttpInfo(index = index)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateIndexResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create geospatial index
     * Creates an in-memory index within this geoshard
     * @param index Geospatial index name
     * @return ApiResponse<CreateIndexResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createIndexWithHttpInfo(index: kotlin.String) : ApiResponse<CreateIndexResponse?> {
        val localVariableConfig = createIndexRequestConfig(index = index)

        return request<Unit, CreateIndexResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createIndex
     *
     * @param index Geospatial index name
     * @return RequestConfig
     */
    fun createIndexRequestConfig(index: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/shard/{index}/".replace("{"+"index"+"}", encodeURIComponent(index.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Deletes geospatial index
     * Drop index. All keys will be lost
     * @param index Geospatial index name
     * @return DropIndexResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun dropIndex(index: kotlin.String) : DropIndexResponse {
        val localVarResponse = dropIndexWithHttpInfo(index = index)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DropIndexResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deletes geospatial index
     * Drop index. All keys will be lost
     * @param index Geospatial index name
     * @return ApiResponse<DropIndexResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun dropIndexWithHttpInfo(index: kotlin.String) : ApiResponse<DropIndexResponse?> {
        val localVariableConfig = dropIndexRequestConfig(index = index)

        return request<Unit, DropIndexResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dropIndex
     *
     * @param index Geospatial index name
     * @return RequestConfig
     */
    fun dropIndexRequestConfig(index: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/shard/{index}/".replace("{"+"index"+"}", encodeURIComponent(index.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Insert key into index
     * Inserts key into geospatial index
     * @param index Geospatial index name
     * @param insertKey 
     * @return InsertKeyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun insertKey(index: kotlin.String, insertKey: InsertKey) : InsertKeyResponse {
        val localVarResponse = insertKeyWithHttpInfo(index = index, insertKey = insertKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InsertKeyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Insert key into index
     * Inserts key into geospatial index
     * @param index Geospatial index name
     * @param insertKey 
     * @return ApiResponse<InsertKeyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun insertKeyWithHttpInfo(index: kotlin.String, insertKey: InsertKey) : ApiResponse<InsertKeyResponse?> {
        val localVariableConfig = insertKeyRequestConfig(index = index, insertKey = insertKey)

        return request<InsertKey, InsertKeyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation insertKey
     *
     * @param index Geospatial index name
     * @param insertKey 
     * @return RequestConfig
     */
    fun insertKeyRequestConfig(index: kotlin.String, insertKey: InsertKey) : RequestConfig<InsertKey> {
        val localVariableBody = insertKey
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/shard/{index}/".replace("{"+"index"+"}", encodeURIComponent(index.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Insert multiple keys into index
     * Inserts multiple keys into geospatial index
     * @param index Geospatial index name
     * @param insertKeyBatch 
     * @return InsertKeyBatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun insertKeyBatch(index: kotlin.String, insertKeyBatch: InsertKeyBatch) : InsertKeyBatchResponse {
        val localVarResponse = insertKeyBatchWithHttpInfo(index = index, insertKeyBatch = insertKeyBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InsertKeyBatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Insert multiple keys into index
     * Inserts multiple keys into geospatial index
     * @param index Geospatial index name
     * @param insertKeyBatch 
     * @return ApiResponse<InsertKeyBatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun insertKeyBatchWithHttpInfo(index: kotlin.String, insertKeyBatch: InsertKeyBatch) : ApiResponse<InsertKeyBatchResponse?> {
        val localVariableConfig = insertKeyBatchRequestConfig(index = index, insertKeyBatch = insertKeyBatch)

        return request<InsertKeyBatch, InsertKeyBatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation insertKeyBatch
     *
     * @param index Geospatial index name
     * @param insertKeyBatch 
     * @return RequestConfig
     */
    fun insertKeyBatchRequestConfig(index: kotlin.String, insertKeyBatch: InsertKeyBatch) : RequestConfig<InsertKeyBatch> {
        val localVariableBody = insertKeyBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/shard/{index}/batch/".replace("{"+"index"+"}", encodeURIComponent(index.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Search index for objects nearby
     * Search geospatial index for all keys within some distance
     * @param index Geospatial index name
     * @param lat Latitude
     * @param lng Longitude
     * @param range Search radius in kilometers
     * @param count Maximum number of neighbors that can be returned (default 100) (optional)
     * @param sorted If enabled neighbors will be sorted by distance, nearest to furthest (default false) (optional)
     * @return QueryRangeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queryRange(index: kotlin.String, lat: kotlin.Double, lng: kotlin.Double, range: kotlin.Int, count: kotlin.Int? = null, sorted: kotlin.Boolean? = null) : QueryRangeResponse {
        val localVarResponse = queryRangeWithHttpInfo(index = index, lat = lat, lng = lng, range = range, count = count, sorted = sorted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueryRangeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search index for objects nearby
     * Search geospatial index for all keys within some distance
     * @param index Geospatial index name
     * @param lat Latitude
     * @param lng Longitude
     * @param range Search radius in kilometers
     * @param count Maximum number of neighbors that can be returned (default 100) (optional)
     * @param sorted If enabled neighbors will be sorted by distance, nearest to furthest (default false) (optional)
     * @return ApiResponse<QueryRangeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queryRangeWithHttpInfo(index: kotlin.String, lat: kotlin.Double, lng: kotlin.Double, range: kotlin.Int, count: kotlin.Int?, sorted: kotlin.Boolean?) : ApiResponse<QueryRangeResponse?> {
        val localVariableConfig = queryRangeRequestConfig(index = index, lat = lat, lng = lng, range = range, count = count, sorted = sorted)

        return request<Unit, QueryRangeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queryRange
     *
     * @param index Geospatial index name
     * @param lat Latitude
     * @param lng Longitude
     * @param range Search radius in kilometers
     * @param count Maximum number of neighbors that can be returned (default 100) (optional)
     * @param sorted If enabled neighbors will be sorted by distance, nearest to furthest (default false) (optional)
     * @return RequestConfig
     */
    fun queryRangeRequestConfig(index: kotlin.String, lat: kotlin.Double, lng: kotlin.Double, range: kotlin.Int, count: kotlin.Int?, sorted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("lat", listOf(lat.toString()))
                put("lng", listOf(lng.toString()))
                put("range", listOf(range.toString()))
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (sorted != null) {
                    put("sorted", listOf(sorted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/shard/{index}/".replace("{"+"index"+"}", encodeURIComponent(index.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Search multiple indices for objects nearby
     * Search geospatial many indices for all keys within some distance
     * @param indices List of indices to search
     * @param lat Latitude
     * @param lng Longitude
     * @param range Search radius in kilometers
     * @param count Maximum number of neighbors that can be returned (default 100) (optional)
     * @param sorted If enabled neighbors will be sorted by distance, nearest to furthest (default false) (optional)
     * @return QueryRangeManyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queryRangeMany(indices: kotlin.collections.List<kotlin.String>, lat: kotlin.Double, lng: kotlin.Double, range: kotlin.Int, count: kotlin.Int? = null, sorted: kotlin.Boolean? = null) : QueryRangeManyResponse {
        val localVarResponse = queryRangeManyWithHttpInfo(indices = indices, lat = lat, lng = lng, range = range, count = count, sorted = sorted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueryRangeManyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search multiple indices for objects nearby
     * Search geospatial many indices for all keys within some distance
     * @param indices List of indices to search
     * @param lat Latitude
     * @param lng Longitude
     * @param range Search radius in kilometers
     * @param count Maximum number of neighbors that can be returned (default 100) (optional)
     * @param sorted If enabled neighbors will be sorted by distance, nearest to furthest (default false) (optional)
     * @return ApiResponse<QueryRangeManyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queryRangeManyWithHttpInfo(indices: kotlin.collections.List<kotlin.String>, lat: kotlin.Double, lng: kotlin.Double, range: kotlin.Int, count: kotlin.Int?, sorted: kotlin.Boolean?) : ApiResponse<QueryRangeManyResponse?> {
        val localVariableConfig = queryRangeManyRequestConfig(indices = indices, lat = lat, lng = lng, range = range, count = count, sorted = sorted)

        return request<Unit, QueryRangeManyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queryRangeMany
     *
     * @param indices List of indices to search
     * @param lat Latitude
     * @param lng Longitude
     * @param range Search radius in kilometers
     * @param count Maximum number of neighbors that can be returned (default 100) (optional)
     * @param sorted If enabled neighbors will be sorted by distance, nearest to furthest (default false) (optional)
     * @return RequestConfig
     */
    fun queryRangeManyRequestConfig(indices: kotlin.collections.List<kotlin.String>, lat: kotlin.Double, lng: kotlin.Double, range: kotlin.Int, count: kotlin.Int?, sorted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("indices", toMultiValue(indices.toList(), "multi"))
                put("lat", listOf(lat.toString()))
                put("lng", listOf(lng.toString()))
                put("range", listOf(range.toString()))
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (sorted != null) {
                    put("sorted", listOf(sorted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/shard/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Remove key from index
     * Removes key from geospatial index
     * @param index Geospatial index name
     * @param removeKey 
     * @return RemoveKeyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeKey(index: kotlin.String, removeKey: RemoveKey) : RemoveKeyResponse {
        val localVarResponse = removeKeyWithHttpInfo(index = index, removeKey = removeKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RemoveKeyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove key from index
     * Removes key from geospatial index
     * @param index Geospatial index name
     * @param removeKey 
     * @return ApiResponse<RemoveKeyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeKeyWithHttpInfo(index: kotlin.String, removeKey: RemoveKey) : ApiResponse<RemoveKeyResponse?> {
        val localVariableConfig = removeKeyRequestConfig(index = index, removeKey = removeKey)

        return request<RemoveKey, RemoveKeyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeKey
     *
     * @param index Geospatial index name
     * @param removeKey 
     * @return RequestConfig
     */
    fun removeKeyRequestConfig(index: kotlin.String, removeKey: RemoveKey) : RequestConfig<RemoveKey> {
        val localVariableBody = removeKey
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v1/shard/{index}/".replace("{"+"index"+"}", encodeURIComponent(index.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Remove multiple keys from index
     * Removes multiple keys from geospatial index
     * @param index Geospatial index name
     * @param removeKeyBatch 
     * @return RemoveKeyBatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeKeyBatch(index: kotlin.String, removeKeyBatch: RemoveKeyBatch) : RemoveKeyBatchResponse {
        val localVarResponse = removeKeyBatchWithHttpInfo(index = index, removeKeyBatch = removeKeyBatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RemoveKeyBatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove multiple keys from index
     * Removes multiple keys from geospatial index
     * @param index Geospatial index name
     * @param removeKeyBatch 
     * @return ApiResponse<RemoveKeyBatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeKeyBatchWithHttpInfo(index: kotlin.String, removeKeyBatch: RemoveKeyBatch) : ApiResponse<RemoveKeyBatchResponse?> {
        val localVariableConfig = removeKeyBatchRequestConfig(index = index, removeKeyBatch = removeKeyBatch)

        return request<RemoveKeyBatch, RemoveKeyBatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeKeyBatch
     *
     * @param index Geospatial index name
     * @param removeKeyBatch 
     * @return RequestConfig
     */
    fun removeKeyBatchRequestConfig(index: kotlin.String, removeKeyBatch: RemoveKeyBatch) : RequestConfig<RemoveKeyBatch> {
        val localVariableBody = removeKeyBatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v1/shard/{index}/batch/".replace("{"+"index"+"}", encodeURIComponent(index.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
